"""
–°–µ—Ä–≤–∏—Å –ø–∞—Ä—Å–∏–Ω–≥–∞ –≥–ª–∞–≤ –¥–ª—è –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
–û–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –ø–∞—Ä—Å–µ—Ä–æ–≤
"""
import time
import re
import logging
import requests
import sys
import os
from bs4 import BeautifulSoup
from typing import List, Optional
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from app.models import Novel, Chapter, Task
from app import db
from app.services.settings_service import SettingsService
from app.services.log_service import LogService

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ –ø–∞—Ä—Å–µ—Ä–æ–≤
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
sys.path.insert(0, project_root)

try:
    from parsers import create_parser, create_parser_from_url, detect_source, get_available_sources
    PARSERS_AVAILABLE = True
    LogService.log_info("‚úÖ –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–∞—Ä—Å–µ—Ä–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
except ImportError as e:
    LogService.log_warning(f"‚ö†Ô∏è –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–∞—Ä—Å–µ—Ä–æ–≤ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: {e}")
    PARSERS_AVAILABLE = False

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–≥–µ—Ä
logger = logging.getLogger(__name__)


class WebParserService:
    """–°–µ—Ä–≤–∏—Å –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""

    def __init__(self):
        self.driver = None
        self.wait = None

    def setup_driver(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ Chrome –¥—Ä–∞–π–≤–µ—Ä–∞"""
        chrome_options = Options()
        # chrome_options.add_argument('--headless')  # –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--window-size=1920,1080')
        chrome_options.add_argument('--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
        chrome_options.binary_location = '/usr/bin/chromium-browser'
        chrome_options.add_argument('--incognito')  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∂–∏–º –∏–Ω–∫–æ–≥–Ω–∏—Ç–æ
        chrome_options.add_argument('--disable-extensions')
        chrome_options.add_argument('--disable-plugins')
        chrome_options.add_argument('--disable-background-timer-throttling')
        chrome_options.add_argument('--disable-backgrounding-occluded-windows')
        chrome_options.add_argument('--disable-renderer-backgrounding')
        chrome_options.add_argument('--disable-features=TranslateUI')
        chrome_options.add_argument('--disable-ipc-flooding-protection')
        
        self.driver = webdriver.Chrome(options=chrome_options)
        self.wait = WebDriverWait(self.driver, 30)  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç

    def cleanup_driver(self):
        """–û—á–∏—Å—Ç–∫–∞ –¥—Ä–∞–π–≤–µ—Ä–∞"""
        if self.driver:
            self.driver.quit()
            self.driver = None
            self.wait = None

    def extract_chapter_number(self, url: str) -> int:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –≥–ª–∞–≤—ã –∏–∑ URL"""
        match = re.search(r'/chapter/(\d+)', url)
        return int(match.group(1)) if match else 0

    def parse_novel_chapters(self, novel: Novel) -> List[dict]:
        """–ü–∞—Ä—Å–∏–Ω–≥ –≤—Å–µ—Ö –≥–ª–∞–≤ –Ω–æ–≤–µ–ª–ª—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –ø–∞—Ä—Å–µ—Ä–æ–≤"""
        LogService.log_info(f"üöÄ –ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–µ–ª–ª—ã: {novel.title}", novel_id=novel.id)
        
        novel_url = novel.source_url
        LogService.log_info(f"üìñ URL: {novel_url}", novel_id=novel.id)
        
        # –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É –ø–∞—Ä—Å–µ—Ä–æ–≤
        if PARSERS_AVAILABLE:
            LogService.log_info("‚úÖ –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–∞—Ä—Å–µ—Ä–æ–≤ –¥–æ—Å—Ç—É–ø–Ω–∞", novel_id=novel.id)
            return self._parse_with_new_system(novel, novel_url)
        else:
            LogService.log_warning("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –ø–∞—Ä—Å–µ—Ä", novel_id=novel.id)
            return self._parse_with_legacy_system(novel, novel_url)

    def _parse_with_new_system(self, novel: Novel, novel_url: str) -> List[dict]:
        """–ü–∞—Ä—Å–∏–Ω–≥ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –ø–∞—Ä—Å–µ—Ä–æ–≤"""
        try:
            LogService.log_info("üöÄ –ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π", novel_id=novel.id)
            LogService.log_info("üîç –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∞...", novel_id=novel.id)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫
            detected_source = detect_source(novel_url)
            source_type = novel.source_type if novel.source_type else detected_source
            
            LogService.log_info(f"üìö –ò—Å—Ç–æ—á–Ω–∏–∫: {source_type} (–æ–ø—Ä–µ–¥–µ–ª–µ–Ω: {detected_source})", novel_id=novel.id)
            
            # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∏ –ø—Ä–æ–∫—Å–∏
            auth_cookies = None
            socks_proxy = None
            
            if novel.is_auth_enabled():
                auth_cookies = novel.get_auth_cookies()
                LogService.log_info(f"üîê –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é: {len(auth_cookies)} —Å–∏–º–≤–æ–ª–æ–≤", novel_id=novel.id)
            
            if novel.is_proxy_enabled():
                socks_proxy = novel.get_socks_proxy()
                LogService.log_info(f"üåê –ò—Å–ø–æ–ª—å–∑—É–µ–º SOCKS –ø—Ä–æ–∫—Å–∏: {socks_proxy}", novel_id=novel.id)
            
            # –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—Å–µ—Ä —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
            if source_type == 'epub':
                # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è EPUB —Ñ–∞–π–ª–æ–≤
                epub_path = novel.get_epub_file_path()
                if not epub_path:
                    LogService.log_error(f"‚ùå –î–ª—è EPUB –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –Ω–µ —É–∫–∞–∑–∞–Ω –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É", novel_id=novel.id)
                    return []
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º –≥–ª–∞–≤ –¥–ª—è EPUB
                all_chapters_enabled = novel.config.get('all_chapters', False) if novel.config else False
                max_chapters = None if all_chapters_enabled else (novel.config.get('max_chapters', 10) if novel.config else 10)
                
                # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –≥–ª–∞–≤—É
                start_chapter = novel.config.get('start_chapter', 1) if novel.config else 1
                LogService.log_info(f"üìñ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ EPUB: –Ω–∞—á–∞–ª—å–Ω–∞—è –≥–ª–∞–≤–∞ = {start_chapter}, –º–∞–∫—Å. –≥–ª–∞–≤ = {max_chapters or '–≤—Å–µ'}", novel_id=novel.id)
                
                parser = create_parser('epub', epub_path=epub_path, max_chapters=max_chapters, start_chapter=start_chapter)
                novel_url = epub_path  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –∫–∞–∫ URL
            else:
                parser = create_parser_from_url(novel_url, auth_cookies=auth_cookies, socks_proxy=socks_proxy)
            
            if not parser:
                LogService.log_error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–∞—Ä—Å–µ—Ä –¥–ª—è {source_type}", novel_id=novel.id)
                return self._parse_with_legacy_system(novel, novel_url)
            
            LogService.log_info(f"‚úÖ –ü–∞—Ä—Å–µ—Ä —Å–æ–∑–¥–∞–Ω: {parser.source_name}", novel_id=novel.id)
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≥–ª–∞–≤
            LogService.log_info("üìñ –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≥–ª–∞–≤...", novel_id=novel.id)
            chapters = parser.get_chapter_list(novel_url)
            
            if not chapters:
                LogService.log_warning("‚ö†Ô∏è –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –Ω–∞—à–ª–∞ –≥–ª–∞–≤—ã, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ fallback", novel_id=novel.id)
                return self._parse_with_legacy_system(novel, novel_url)
            
            LogService.log_info(f"üìë –ù–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤: {len(chapters)}", novel_id=novel.id)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –≥–ª–∞–≤
            all_chapters_enabled = novel.config.get('all_chapters', False) if novel.config else False
            
            if all_chapters_enabled:
                limited_chapters = chapters
                LogService.log_info(f"üìä –í—ã–±—Ä–∞–Ω–æ –≤—Å–µ –≥–ª–∞–≤—ã: {len(chapters)} –≥–ª–∞–≤", novel_id=novel.id)
            else:
                max_chapters = novel.config.get('max_chapters', 10) if novel.config else 10
                limited_chapters = chapters[:max_chapters]
                LogService.log_info(f"üìä –í—ã–±—Ä–∞–Ω–æ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: {len(limited_chapters)} –∏–∑ {len(chapters)} –≥–ª–∞–≤", novel_id=novel.id)
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç, –æ–∂–∏–¥–∞–µ–º—ã–π –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º
            result_chapters = []
            for i, chapter in enumerate(limited_chapters, 1):
                if 'url' not in chapter:
                    LogService.log_error(f"‚ö†Ô∏è –ì–ª–∞–≤–∞ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç URL: {chapter}", novel_id=novel.id)
                    chapter['url'] = chapter.get('chapter_id', f"chapter_{i}")
                result_chapters.append({
                    'url': chapter['url'],
                    'title': chapter['title'],
                    'number': chapter.get('number', i)
                })
                LogService.log_info(f"  -> –ì–ª–∞–≤–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: #{chapter.get('number', i)} - {chapter['title'][:50]}...", novel_id=novel.id)
            
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–∞—Ä—Å–µ—Ä
            parser.close()
            
            LogService.log_info(f"‚úÖ –ü–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ: {len(result_chapters)} –≥–ª–∞–≤", novel_id=novel.id)
            return result_chapters
            
        except Exception as e:
            import traceback
            LogService.log_error(f"‚ùå –û—à–∏–±–∫–∞ –≤ –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ –ø–∞—Ä—Å–µ—Ä–æ–≤: {e}", novel_id=novel.id)
            LogService.log_error(f"–ü–æ–ª–Ω—ã–π —Å—Ç–µ–∫ –æ—à–∏–±–∫–∏: {traceback.format_exc()}", novel_id=novel.id)
            LogService.log_info("üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É –ø–∞—Ä—Å–∏–Ω–≥–∞", novel_id=novel.id)
            # –û—Ç–∫–∞—Ç –∫ —Å—Ç–∞—Ä–æ–π —Å–∏—Å—Ç–µ–º–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
            return self._parse_with_legacy_system(novel, novel_url)

    def _parse_with_legacy_system(self, novel: Novel, novel_url: str) -> List[dict]:
        """–£—Å—Ç–∞—Ä–µ–≤—à–∏–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
        try:
            # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è EPUB –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
            if novel.is_epub_source():
                LogService.log_info("üìñ –û–±—Ä–∞–±–æ—Ç–∫–∞ EPUB —Ñ–∞–π–ª–∞ –≤ legacy —Å–∏—Å—Ç–µ–º–µ", novel_id=novel.id)
                try:
                    from parsers.sources.epub_parser import EPUBParser
                    epub_path = novel.get_epub_file_path()
                    
                    if not epub_path or not os.path.exists(epub_path):
                        LogService.log_error(f"EPUB —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {epub_path}", novel_id=novel.id)
                        return []
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º –≥–ª–∞–≤
                    all_chapters_enabled = novel.config.get('all_chapters', False) if novel.config else False
                    max_chapters = None if all_chapters_enabled else (novel.config.get('max_chapters', 10) if novel.config else 10)
                    
                    # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –≥–ª–∞–≤—É
                    start_chapter = novel.config.get('start_chapter', 1) if novel.config else 1
                    LogService.log_info(f"üìñ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ EPUB (legacy): –Ω–∞—á–∞–ª—å–Ω–∞—è –≥–ª–∞–≤–∞ = {start_chapter}, –º–∞–∫—Å. –≥–ª–∞–≤ = {max_chapters or '–≤—Å–µ'}", novel_id=novel.id)
                    
                    LogService.log_info(f"üìñ [Legacy] –°–æ–∑–¥–∞–µ–º EPUB –ø–∞—Ä—Å–µ—Ä: start_chapter={start_chapter}, max_chapters={max_chapters}", novel_id=novel.id)
                    parser = EPUBParser(epub_path=epub_path, max_chapters=max_chapters, start_chapter=start_chapter)
                    if not parser.load_epub(epub_path):
                        LogService.log_error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å EPUB —Ñ–∞–π–ª", novel_id=novel.id)
                        return []
                    
                    chapters = parser.get_chapter_list()
                    LogService.log_info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ –≥–ª–∞–≤ –∏–∑ EPUB: {len(chapters)}" + 
                                       (f" (–ª–∏–º–∏—Ç: {max_chapters})" if max_chapters else " (–≤—Å–µ –≥–ª–∞–≤—ã)"), 
                                       novel_id=novel.id)
                    
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç, –æ–∂–∏–¥–∞–µ–º—ã–π –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º
                    result_chapters = []
                    for i, chapter in enumerate(chapters, 1):
                        result_chapters.append({
                            'url': f"chapter_{chapter['number']}",  # –ò—Å–ø–æ–ª—å–∑—É–µ–º ID –≥–ª–∞–≤—ã –∫–∞–∫ URL
                            'title': chapter['title'],
                            'number': chapter['number']
                        })
                        LogService.log_info(f"  -> [Legacy] –ì–ª–∞–≤–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: #{chapter['number']} - {chapter['title'][:50]}...", novel_id=novel.id)
                    
                    parser.close()
                    return result_chapters
                    
                except Exception as e:
                    LogService.log_error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ EPUB –≤ legacy —Å–∏—Å—Ç–µ–º–µ: {e}", novel_id=novel.id)
                    return []
            
            # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º URL - –¥–æ–±–∞–≤–ª—è–µ–º —Å–ª–µ—à –≤ –∫–æ–Ω—Ü–µ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
            if not novel_url.endswith('/'):
                novel_url += '/'
            
            # –î–ª—è Qidian –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–∞—Ç–∞–ª–æ–≥–∞, –¥–ª—è –¥—Ä—É–≥–∏—Ö - –æ—Å–Ω–æ–≤–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
            if 'qidian.com' in novel_url:
                # –ò–∑–≤–ª–µ–∫–∞–µ–º ID –∫–Ω–∏–≥–∏ –∏–∑ URL Qidian
                import re
                book_id_match = re.search(r'/book/(\d+)/?', novel_url)
                if book_id_match:
                    book_id = book_id_match.group(1)
                    catalog_url = f"https://m.qidian.com/book/{book_id}/catalog"
                    LogService.log_info(f"–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ç–∞–ª–æ–≥–∞ Qidian: {catalog_url}", novel_id=novel.id)
                else:
                    catalog_url = novel_url
                    LogService.log_info("–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –Ω–æ–≤–µ–ª–ª—ã...", novel_id=novel.id)
            else:
                catalog_url = novel_url
                LogService.log_info("–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –Ω–æ–≤–µ–ª–ª—ã...", novel_id=novel.id)
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–±–∏–ª—å–Ω—ã–π User-Agent –¥–ª—è Qidian
            if 'qidian.com' in catalog_url:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                }
            else:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                }
                
            response = requests.get(catalog_url, headers=headers, timeout=30)
            response.raise_for_status()
            LogService.log_info("–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞", novel_id=novel.id)

            # –ü–∞—Ä—Å–∏–º HTML
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # –ò—â–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –≥–ª–∞–≤—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∞–π—Ç–∞
            LogService.log_info("–ü–æ–∏—Å–∫ —Å—Å—ã–ª–æ–∫ –Ω–∞ –≥–ª–∞–≤—ã...", novel_id=novel.id)
            
            if 'qidian.com' in catalog_url:
                # –î–ª—è Qidian –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
                chapter_links = soup.select('a[href*="/chapter/"]')
            else:
                # –î–ª—è –¥—Ä—É–≥–∏—Ö —Å–∞–π—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–π –º–µ—Ç–æ–¥
                chapter_links = soup.find_all('a', href=re.compile(r'/chapter/\d+'))
                
            LogService.log_info(f"–ù–∞–π–¥–µ–Ω–æ —Å—Å—ã–ª–æ–∫ –Ω–∞ –≥–ª–∞–≤—ã: {len(chapter_links)}", novel_id=novel.id)

            all_chapters = []
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–æ–≤–µ–ª–ª—ã
            all_chapters_enabled = novel.config.get('all_chapters', False) if novel.config else False
            max_chapters = novel.config.get('max_chapters', 10) if novel.config else 10

            # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –≥–ª–∞–≤—ã —Å–Ω–∞—á–∞–ª–∞
            temp_chapters = []
            for i, link in enumerate(chapter_links):
                href = link.get('href')
                title = link.text.strip()
                
                if 'qidian.com' in catalog_url:
                    # –î–ª—è Qidian —Å–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
                    if href and title:
                        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ URL –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ
                        if href.startswith('//'):
                            full_url = f"https:{href}"
                        elif href.startswith('/'):
                            full_url = f"https://m.qidian.com{href}"
                        else:
                            full_url = href
                            
                        # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ –≥–ª–∞–≤—ã
                        if self._is_qidian_story_chapter(title):
                            temp_chapters.append({
                                'url': full_url,
                                'title': title,
                                'number': i + 1  # –ü—Ä–æ—Å—Ç–æ –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
                            })
                else:
                    # –î–ª—è –¥—Ä—É–≥–∏—Ö —Å–∞–π—Ç–æ–≤ —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞
                    chapter_num = self.extract_chapter_number(href)
                    
                    if chapter_num > 0:
                        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π URL –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π
                        if href.startswith('/'):
                            full_url = f"https://novelbins.com{href}"
                        else:
                            full_url = href
                            
                        temp_chapters.append({
                            'url': full_url,
                            'title': title,
                            'number': chapter_num
                        })

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –Ω–æ–º–µ—Ä—É –≥–ª–∞–≤—ã
            temp_chapters.sort(key=lambda x: x['number'])
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –≥–ª–∞–≤
            if all_chapters_enabled:
                all_chapters = temp_chapters
                LogService.log_info(f"–í—ã–±—Ä–∞–Ω–æ –≤—Å–µ –≥–ª–∞–≤—ã: {len(all_chapters)} –≥–ª–∞–≤", novel_id=novel.id)
            else:
                all_chapters = temp_chapters[:max_chapters]
                LogService.log_info(f"–í—ã–±—Ä–∞–Ω–æ –ø–µ—Ä–≤—ã—Ö {len(all_chapters)} –≥–ª–∞–≤ –∏–∑ {len(temp_chapters)} –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö", novel_id=novel.id)

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –Ω–æ–º–µ—Ä—É
            all_chapters.sort(key=lambda x: x['number'])
            LogService.log_info(f"–í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤: {len(all_chapters)}", novel_id=novel.id)

            return all_chapters

        except Exception as e:
            LogService.log_error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –≥–ª–∞–≤: {e}", novel_id=novel.id)
            return []
    
    def _is_qidian_story_chapter(self, title: str) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≥–ª–∞–≤–∞ —á–∞—Å—Ç—å—é –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è Qidian
        """
        if not title or len(title.strip()) < 3:
            return False
            
        # –ì–ª–∞–≤—ã –∏—Å—Ç–æ—Ä–∏–∏ –æ–±—ã—á–Ω–æ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å "Á¨¨" (–≥–ª–∞–≤–∞)
        if title.startswith('Á¨¨') and ('Á´†' in title or 'Âõû' in title):
            return True
            
        # –°–ª—É–∂–µ–±–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
        service_keywords = [
            'Êñ∞‰π¶', 'ÂèëÂ∏É', 'ÈÄöÁü•', 'ÂÖ¨Âëä', 'ËØ¥Êòé', 'ÊäΩÂ•ñ', 'Ê¥ªÂä®',
            'ÊïôÁ®ã', 'Â§ñ‰º†', 'Áï™Â§ñ', 'ÊÑüË®Ä', 'Êé®Ëçê', 'È™óÂ≠ê', 'ÂÜíÂÖÖ',
            'Êµ∑Èáè', 'iPad', 'Ëµ∑ÁÇπÂ∏Å', 'ÁªèÈ™å', 'Êé®ËçêÁ•®',
            '2022-', '2023-', '2024-', '2025-',
            '‰ΩúÂÆ∂ÂÖ•È©ª', 'Âç≥Êõ¥Âç≥Áúã', 'ËøòÊúâÁï™Â§ñ'
        ]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Å–ª—É–∂–µ–±–Ω—ã—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
        for keyword in service_keywords:
            if keyword in title:
                return False
                
        # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—á–∏—Ç–∞–µ–º –≥–ª–∞–≤–æ–π –∏—Å—Ç–æ—Ä–∏–∏
        return True

    def parse_chapter_content(self, chapter_url: str, chapter_number: int, novel: Novel = None) -> Optional[str]:
        """–ü–∞—Ä—Å–∏–Ω–≥ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≥–ª–∞–≤—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã –ø–∞—Ä—Å–µ—Ä–æ–≤"""
        LogService.log_info(f"üìÑ –ó–∞–≥—Ä—É–∑–∫–∞ –≥–ª–∞–≤—ã {chapter_number}: {chapter_url}")
        
        # –ï—Å–ª–∏ –Ω–æ–≤–µ–ª–ª–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–∞, –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –µ—ë
        if not novel:
            # –î–ª—è EPUB –≥–ª–∞–≤ –∏—â–µ–º –ø–æ source_type
            if chapter_url.startswith('chapter_'):
                novel = Novel.query.filter_by(source_type='epub').first()
            else:
                # –î–ª—è –≤–µ–±-–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –∏—â–µ–º –ø–æ source_url
                novel = Novel.query.filter_by(source_url=chapter_url).first()

        # –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É –ø–∞—Ä—Å–µ—Ä–æ–≤
        if PARSERS_AVAILABLE:
            return self._parse_chapter_with_new_system(chapter_url, chapter_number, novel)
        else:
            LogService.log_warning("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è –≥–ª–∞–≤—ã", chapter_id=chapter_number)
            return self._parse_chapter_with_legacy_system(chapter_url, chapter_number, novel)

    def _parse_chapter_with_new_system(self, chapter_url: str, chapter_number: int, novel: Novel = None) -> Optional[str]:
        """–ü–∞—Ä—Å–∏–Ω–≥ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≥–ª–∞–≤—ã —Å –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º cookies –∏ –ø—Ä–æ–∫—Å–∏ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –Ω–æ–≤–µ–ª–ª—ã
            auth_cookies = None
            socks_proxy = None
            
            if novel:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≥–ª–∞–≤–∞ VIP/–ø–ª–∞—Ç–Ω–æ–π
                is_vip_chapter = self._is_vip_chapter(chapter_number, chapter_url, novel)
                
                # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥—Ö–æ–¥—è—â–∏–µ cookies –¥–ª—è —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
                if novel.is_auth_enabled() or novel.is_vip_cookies_enabled():
                    auth_cookies = novel.get_effective_cookies(is_vip_content=is_vip_chapter)
                    cookie_type = "VIP" if is_vip_chapter and novel.is_vip_cookies_enabled() else "–æ–±—ã—á–Ω—ã–µ"
                    LogService.log_info(f"üîê –ò—Å–ø–æ–ª—å–∑—É–µ–º {cookie_type} cookies –¥–ª—è –≥–ª–∞–≤—ã {chapter_number} (VIP: {is_vip_chapter})", chapter_id=chapter_number)
                
                if novel.is_proxy_enabled():
                    socks_proxy = novel.get_socks_proxy()
                    LogService.log_info(f"üåê –ò—Å–ø–æ–ª—å–∑—É–µ–º SOCKS –ø—Ä–æ–∫—Å–∏ –¥–ª—è –≥–ª–∞–≤—ã {chapter_number}: {socks_proxy}", chapter_id=chapter_number)
            
            # –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—Å–µ—Ä –¥–ª—è URL –≥–ª–∞–≤—ã —Å cookies –∏ –ø—Ä–æ–∫—Å–∏
            if novel and novel.is_epub_source():
                # –î–ª—è EPUB –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä
                epub_path = novel.get_epub_file_path()
                # –í–ê–ñ–ù–û: –ø–µ—Ä–µ–¥–∞–µ–º start_chapter, —á—Ç–æ–±—ã –ø–∞—Ä—Å–µ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–ª –≥–ª–∞–≤—ã
                start_chapter = novel.config.get('start_chapter', 1) if novel.config else 1
                LogService.log_info(f"üìñ –°–æ–∑–¥–∞–µ–º EPUB –ø–∞—Ä—Å–µ—Ä –¥–ª—è –≥–ª–∞–≤—ã —Å start_chapter={start_chapter}", chapter_id=chapter_number)
                parser = create_parser('epub', epub_path=epub_path, start_chapter=start_chapter)
            else:
                # –î–ª—è –≤–µ–±-–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º URL
                parser = create_parser_from_url(chapter_url, auth_cookies=auth_cookies, socks_proxy=socks_proxy)
            
            if not parser:
                LogService.log_warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–∞—Ä—Å–µ—Ä –¥–ª—è –≥–ª–∞–≤—ã {chapter_number}, –∏—Å–ø–æ–ª—å–∑—É–µ–º legacy", chapter_id=chapter_number)
                return self._parse_chapter_with_legacy_system(chapter_url, chapter_number, novel)
            
            # –ü–æ–ª—É—á–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≥–ª–∞–≤—ã
            chapter_data = parser.get_chapter_content(chapter_url)
            if not chapter_data or not chapter_data.get('content'):
                LogService.log_error(f"‚ùå –ü—É—Å—Ç–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≥–ª–∞–≤—ã {chapter_number}", chapter_id=chapter_number)
                parser.close()
                return None
            
            content = chapter_data['content']
            is_locked = chapter_data.get('is_locked', False)
            
            if is_locked:
                LogService.log_warning(f"üîí –ì–ª–∞–≤–∞ {chapter_number} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞, –ø–æ–ª—É—á–µ–Ω–æ –ø—Ä–µ–≤—å—é: {len(content)} —Å–∏–º–≤–æ–ª–æ–≤", chapter_id=chapter_number)
                # –î–ª—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≥–ª–∞–≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–≤—å—é —Å –ø–æ–º–µ—Ç–∫–æ–π
                if len(content) < 200:
                    content = f"[–ó–ê–ë–õ–û–ö–ò–†–û–í–ê–ù–ê - –ü–†–ï–í–¨–Æ] {content}"
            else:
                LogService.log_info(f"‚úÖ –ì–ª–∞–≤–∞ {chapter_number} –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {len(content)} —Å–∏–º–≤–æ–ª–æ–≤", chapter_id=chapter_number)
            
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–∞—Ä—Å–µ—Ä
            parser.close()
            
            return content
            
        except Exception as e:
            LogService.log_error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≥–ª–∞–≤—ã {chapter_number} –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π: {e}", chapter_id=chapter_number)
            # –û—Ç–∫–∞—Ç –∫ —Å—Ç–∞—Ä–æ–π —Å–∏—Å—Ç–µ–º–µ
            return self._parse_chapter_with_legacy_system(chapter_url, chapter_number, novel)

    def _is_vip_chapter(self, chapter_number: int, chapter_url: str, novel) -> bool:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ VIP/–ø–ª–∞—Ç–Ω—ã—Ö –≥–ª–∞–≤"""
        try:
            # –î–ª—è Qidian –≥–ª–∞–≤—ã –ø–æ—Å–ª–µ 130 –æ–±—ã—á–Ω–æ VIP
            if 'qidian.com' in chapter_url:
                if chapter_number and int(chapter_number) > 130:
                    return True
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º URL –Ω–∞ –Ω–∞–ª–∏—á–∏–µ VIP –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
            if 'vip' in chapter_url.lower():
                return True
            
            # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–∞–π—Ç–æ–≤
            
            return False
            
        except Exception as e:
            LogService.log_warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ VIP —Å—Ç–∞—Ç—É—Å–∞ –≥–ª–∞–≤—ã {chapter_number}: {e}")
            return False
    
    def _parse_chapter_with_legacy_system(self, chapter_url: str, chapter_number: int, novel: Novel = None) -> Optional[str]:
        """–£—Å—Ç–∞—Ä–µ–≤—à–∏–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≥–ª–∞–≤"""

        try:
            # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è EPUB –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
            if novel and novel.is_epub_source():
                LogService.log_info(f"üìñ –û–±—Ä–∞–±–æ—Ç–∫–∞ EPUB –≥–ª–∞–≤—ã {chapter_number} –≤ legacy —Å–∏—Å—Ç–µ–º–µ", chapter_id=chapter_number)
                try:
                    from parsers.sources.epub_parser import EPUBParser
                    epub_path = novel.get_epub_file_path()
                    
                    if not epub_path or not os.path.exists(epub_path):
                        LogService.log_error(f"EPUB —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {epub_path}", chapter_id=chapter_number)
                        return None
                    
                    # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –≥–ª–∞–≤—É –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ –Ω–æ–≤–µ–ª–ª—ã
                    start_chapter = novel.config.get('start_chapter', 1) if novel and novel.config else 1
                    
                    # –ü—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≥–ª–∞–≤—ã —Ç–æ–∂–µ –Ω—É–∂–Ω–æ —É—á–∏—Ç—ã–≤–∞—Ç—å start_chapter
                    LogService.log_info(f"üìñ [Legacy content] –°–æ–∑–¥–∞–µ–º EPUB –ø–∞—Ä—Å–µ—Ä –¥–ª—è –≥–ª–∞–≤—ã {chapter_number}: start_chapter={start_chapter}", chapter_id=chapter_number)
                    parser = EPUBParser(epub_path=epub_path, start_chapter=start_chapter)
                    if not parser.load_epub(epub_path):
                        LogService.log_error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å EPUB —Ñ–∞–π–ª", chapter_id=chapter_number)
                        return None
                    
                    # –ü–æ–ª—É—á–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≥–ª–∞–≤—ã
                    chapter_data = parser.get_chapter_content(chapter_url)
                    parser.close()
                    
                    if chapter_data and chapter_data.get('content'):
                        LogService.log_info(f"‚úÖ EPUB –≥–ª–∞–≤–∞ {chapter_number} –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {len(chapter_data['content'])} —Å–∏–º–≤–æ–ª–æ–≤", chapter_id=chapter_number)
                        return chapter_data['content']
                    else:
                        LogService.log_error(f"‚ùå –ü—É—Å—Ç–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ EPUB –≥–ª–∞–≤—ã {chapter_number}", chapter_id=chapter_number)
                        return None
                        
                except Exception as e:
                    LogService.log_error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ EPUB –≥–ª–∞–≤—ã {chapter_number} –≤ legacy —Å–∏—Å—Ç–µ–º–µ: {e}", chapter_id=chapter_number)
                    return None
            
            # –î–ª—è –≤–µ–±-–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –≥–ª–∞–≤—ã
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            }
            response = requests.get(chapter_url, headers=headers, timeout=30)
            response.raise_for_status()

            # –ü–∞—Ä—Å–∏–º HTML
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # –ò—â–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º
            content_div = soup.find('div', class_='page-content-wrapper')
            if not content_div:
                LogService.log_error("–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return None

            # –£–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            for element in content_div.find_all(['script', 'style', 'nav', 'button']):
                element.decompose()

            # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–∞—Ä–∞–≥—Ä–∞—Ñ—ã
            paragraphs = []
            p_elements = content_div.find_all('p')

            for p in p_elements:
                text = p.get_text().strip()
                if text and len(text) > 30 and not text.startswith('Chapter'):
                    paragraphs.append(text)

            # –ï—Å–ª–∏ –º–∞–ª–æ –ø–∞—Ä–∞–≥—Ä–∞—Ñ–æ–≤, –±–µ—Ä—ë–º –≤–µ—Å—å —Ç–µ–∫—Å—Ç
            if len(paragraphs) < 5:
                text = content_div.get_text()
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                paragraphs = [line for line in lines if len(line) > 50]

            content = '\n\n'.join(paragraphs)
            word_count = len(content.split())

            LogService.log_info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ {len(paragraphs)} –ø–∞—Ä–∞–≥—Ä–∞—Ñ–æ–≤, {word_count} —Å–ª–æ–≤")

            return content

        except Exception as e:
            LogService.log_error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≥–ª–∞–≤—ã {chapter_number}: {e}")
            return None

    def parse_novel(self, novel_id: int, task_id: int = None) -> bool:
        """–ü–æ–ª–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–µ–ª–ª—ã"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–µ–ª–ª—É
            novel = Novel.query.get(novel_id)
            if not novel:
                LogService.log_error(f"–ù–æ–≤–µ–ª–ª–∞ {novel_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", novel_id=novel_id, task_id=task_id)
                return False

            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É
            if task_id:
                task = Task.query.get(task_id)
            else:
                task = Task.query.filter_by(novel_id=novel_id, task_type='parse').first()
            
            if task:
                task.status = 'running'
                db.session.commit()

            LogService.log_info(f"–ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–µ–ª–ª—ã: {novel.title}", novel_id=novel_id, task_id=task_id)
            print(f"üöÄ –ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–µ–ª–ª—ã: {novel.title}")
            print(f"üìä –ó–∞–¥–∞—á–∞ #{task_id}: –ü–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤–µ–ª–ª—ã '{novel.title}'")

            # –ü–∞—Ä—Å–∏–º –≤—Å–µ –≥–ª–∞–≤—ã
            LogService.log_info("–ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ —Å–ø–∏—Å–∫–∞ –≥–ª–∞–≤...", novel_id=novel_id, task_id=task_id)
            print(f"üîç –ü–æ–∏—Å–∫ –≥–ª–∞–≤ –¥–ª—è –Ω–æ–≤–µ–ª–ª—ã '{novel.title}'...")
            chapters_data = self.parse_novel_chapters(novel)
            if not chapters_data:
                LogService.log_error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≥–ª–∞–≤", novel_id=novel_id, task_id=task_id)
                return False

            LogService.log_info(f"–ù–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞: {len(chapters_data)}", novel_id=novel_id, task_id=task_id)
            print(f"üìö –ù–∞–π–¥–µ–Ω–æ {len(chapters_data)} –≥–ª–∞–≤ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞")

            # –ü–∞—Ä—Å–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–∞–∂–¥–æ–π –≥–ª–∞–≤—ã
            success_count = 0
            for i, chapter_data in enumerate(chapters_data):
                LogService.log_info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–ª–∞–≤—ã {i+1}/{len(chapters_data)}: {chapter_data['title']}", 
                                  novel_id=novel_id, task_id=task_id)
                print(f"üìñ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–ª–∞–≤—ã {i+1}/{len(chapters_data)}: {chapter_data['title']}")

                # –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ù–ê –°–£–©–ï–°–¢–í–û–í–ê–ù–ò–ï –ì–õ–ê–í–´
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ –Ω–æ–º–µ—Ä—É –≥–ª–∞–≤—ã –ò –ø–æ URL –¥–ª—è –±–æ–ª—å—à–µ–π –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
                existing_chapter = Chapter.query.filter(
                    Chapter.novel_id == novel_id,
                    db.or_(
                        Chapter.chapter_number == chapter_data['number'],
                        Chapter.url == chapter_data['url']
                    )
                ).first()
                
                if existing_chapter:
                    LogService.log_info(f"–ì–ª–∞–≤–∞ {chapter_data['number']} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (ID: {existing_chapter.id}, —Å—Ç–∞—Ç—É—Å: {existing_chapter.status})", 
                                      novel_id=novel_id, task_id=task_id)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –≥–ª–∞–≤—ã
                    if existing_chapter.status in ['parsed', 'translated', 'edited']:
                        LogService.log_info(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≥–ª–∞–≤—É {chapter_data['number']} - —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞", 
                                          novel_id=novel_id, task_id=task_id)
                        continue
                    else:
                        # –ï—Å–ª–∏ –≥–ª–∞–≤–∞ –≤ —Å—Ç–∞—Ç—É—Å–µ 'pending' –∏–ª–∏ 'error', –æ–±–Ω–æ–≤–ª—è–µ–º –µ—ë
                        LogService.log_info(f"–û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –≥–ª–∞–≤—É {chapter_data['number']} (—Å—Ç–∞—Ç—É—Å: {existing_chapter.status})", 
                                          novel_id=novel_id, task_id=task_id)
                        update_existing = True
                        chapter_to_update = existing_chapter
                else:
                    update_existing = False
                    chapter_to_update = None

                # –ü–∞—Ä—Å–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
                LogService.log_info(f"–ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≥–ª–∞–≤—ã {chapter_data['number']}...", 
                                  novel_id=novel_id, task_id=task_id)
                content = self.parse_chapter_content(chapter_data['url'], chapter_data['number'], novel)
                if not content:
                    LogService.log_warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≥–ª–∞–≤—ã {chapter_data['number']}", 
                                         novel_id=novel_id, task_id=task_id)
                    continue

                # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –≥–ª–∞–≤—É –≤ –ë–î
                if update_existing:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –≥–ª–∞–≤—É
                    chapter_to_update.original_title = chapter_data['title']
                    chapter_to_update.url = chapter_data['url']
                    chapter_to_update.original_text = content
                    chapter_to_update.word_count_original = len(content) if content else 0
                    chapter_to_update.status = 'parsed'
                    
                    chapter = chapter_to_update
                    LogService.log_info(f"–ì–ª–∞–≤–∞ {chapter_data['number']} –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –≤ –ë–î", 
                                      novel_id=novel_id, task_id=task_id, chapter_id=chapter.id)
                else:
                    # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≥–ª–∞–≤—É
                    LogService.log_info(f"üÜï –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≥–ª–∞–≤—É –≤ –ë–î:", novel_id=novel_id, task_id=task_id)
                    LogService.log_info(f"   - –ù–æ–º–µ—Ä: {chapter_data['number']}", novel_id=novel_id, task_id=task_id)
                    LogService.log_info(f"   - –ó–∞–≥–æ–ª–æ–≤–æ–∫: {chapter_data['title']}", novel_id=novel_id, task_id=task_id)
                    LogService.log_info(f"   - URL: {chapter_data['url']}", novel_id=novel_id, task_id=task_id)
                    LogService.log_info(f"   - –†–∞–∑–º–µ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞: {len(content) if content else 0} —Å–∏–º–≤–æ–ª–æ–≤", novel_id=novel_id, task_id=task_id)
                    LogService.log_info(f"   - –ü–µ—Ä–≤—ã–µ 100 —Å–∏–º–≤–æ–ª–æ–≤: {content[:100] if content else '–ø—É—Å—Ç–æ'}...", novel_id=novel_id, task_id=task_id)
                    
                    chapter = Chapter(
                        novel_id=novel_id,
                        chapter_number=chapter_data['number'],
                        original_title=chapter_data['title'],
                        url=chapter_data['url'],
                        original_text=content,
                        word_count_original=len(content) if content else 0,
                        status='parsed'
                    )
                    db.session.add(chapter)
                    LogService.log_info(f"–ì–ª–∞–≤–∞ {chapter_data['number']} —Å–æ–∑–¥–∞–Ω–∞ –≤ –ë–î", 
                                      novel_id=novel_id, task_id=task_id, chapter_id=chapter.id)
                
                success_count += 1
                
                # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∫–æ–º–º–∏—Ç–∏–º –∫–∞–∂–¥—É—é –≥–ª–∞–≤—É –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è race conditions
                try:
                    db.session.commit()
                    LogService.log_info(f"–ì–ª–∞–≤–∞ {chapter_data['number']} —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞", 
                                      novel_id=novel_id, task_id=task_id, chapter_id=chapter.id)
                except Exception as e:
                    db.session.rollback()
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –æ—à–∏–±–∫–æ–π —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏
                    if "UNIQUE constraint failed" in str(e):
                        LogService.log_warning(f"–ì–ª–∞–≤–∞ {chapter_data['number']} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏)", 
                                             novel_id=novel_id, task_id=task_id)
                        # –ù–µ —Å—á–∏—Ç–∞–µ–º —ç—Ç–æ –æ—à–∏–±–∫–æ–π, –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                        success_count -= 1  # –£–±–∏—Ä–∞–µ–º –∏–∑ —Å—á–µ—Ç—á–∏–∫–∞ —É—Å–ø–µ—à–Ω—ã—Ö
                        continue
                    else:
                        LogService.log_error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≥–ª–∞–≤—ã {chapter_data['number']}: {e}", 
                                           novel_id=novel_id, task_id=task_id)
                        success_count -= 1  # –£–±–∏—Ä–∞–µ–º –∏–∑ —Å—á–µ—Ç—á–∏–∫–∞ —É—Å–ø–µ—à–Ω—ã—Ö
                        continue

                # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                if task:
                    progress = int((i + 1) / len(chapters_data) * 100)
                    task.progress = progress
                    db.session.commit()

                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                delay = novel.config.get('request_delay', 1.0) if novel.config else 1.0
                if delay > 0:
                    LogService.log_info(f"–ü–∞—É–∑–∞ {delay} —Å–µ–∫—É–Ω–¥...", novel_id=novel_id, task_id=task_id)
                    time.sleep(delay)

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –Ω–æ–≤–µ–ª–ª—ã
            novel.total_chapters = len(chapters_data)
            novel.parsed_chapters = success_count
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–æ–≤–µ–ª–ª—ã
            if success_count > 0:
                novel.status = 'parsed'
            db.session.commit()

            # –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–¥–∞—á—É
            if task:
                task.status = 'completed'
                task.progress = 100
                db.session.commit()

            LogService.log_info(f"–ü–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω: {success_count}/{len(chapters_data)} –≥–ª–∞–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ", 
                              novel_id=novel_id, task_id=task_id)
            return True

        except Exception as e:
            LogService.log_error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –Ω–æ–≤–µ–ª–ª—ã: {e}", novel_id=novel_id, task_id=task_id)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏
            task = Task.query.filter_by(novel_id=novel_id, task_type='parse').first()
            if task:
                task.status = 'failed'
                db.session.commit()

            return False 